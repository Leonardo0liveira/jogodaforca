# -*- coding: utf-8 -*-
"""JOGO DA FORCA OFICIAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1abH6mQ4G_y8y-i27vJTEkJItawzGCabe
"""

import random # Biblioteca random é utilizada para escolher as palavras aleatórias.

def limpaTela(): # imprime linhas em branco para "limpar o console"
    print("\n" * 20)

def jogo(nome): # A função jogo recebe o parâmetro e inicia jogo
    print(f"Olá {nome}! Bem-vindo ao jogo!")

    while True: # Inicia-se um loop para garantir que a opção "nível de dificuldade" seja válida
        nivel = input("Escolha o nível de dificuldade (fácil, médio, difícil): ")

        if nivel.lower() not in ["fácil", "médio", "difícil"]: # se a entrada não estiver no escopo imprime "Nível inválido"
            print("Nível inválido. Por favor, escolha entre fácil, médio ou difícil.")

        else:
          break
    limite_inferior, limite_superior, tentativas, pontuacao = definir_dificuldade(nivel) # A função definir_dificuldade retorna quatro valores, dependendo da entrada do nível de dificuldade

    palavras = get_palavras(nivel) # A função retorna uma lista de palavras com base no nível escolhido
    palavra_secreta = random.choice(palavras).lower() # A palavra secreta é randomizada
    letras_corretas = [] #Lista para armazenar as letras corretas
    letras_incorretas = [] #Lista para armazenar as letras incorretas (essa lista não retorna para o usuário)
    letras_tentadas = []  # Lista para armazenar as letras tentadas no jogo (essa lista faz o retorno para o usuário)
    boneco = 0 # contador representando a quantidade de partes enforcadas do boneco

    print("Adivinhe a palavra secreta!")
    desenhar_boneco(boneco)

    while True: # Loop para a quantidade de partes enforcadas do boneco, se atingir as 4 tentativas o jogo é encerrado
        if boneco == 4:
            print("Você perdeu! A palavra secreta era:", palavra_secreta)
            break

        for letra in palavra_secreta:
            if letra in letras_corretas:
                print(letra, end=" ")
            else:
                print("_", end=" ")

        print("\n")
        print("Letras já tentadas:", ", ".join(letras_tentadas))  # Imprime as letras já tentadas. ".join" concatena os elementos da lista_tentada em uma string

        if all(letra in letras_corretas for letra in palavra_secreta):
            print(f"Parabéns, {nome}! Você acertou a palavra secreta:", palavra_secreta) # Mensagem impressa quando o jogador acerta
            print(f"Sua pontuação: {pontuacao}") # Imprime a pontuação
            return pontuacao # Retorna a pontuação e acaba a primeira partida

        palpite = input("Digite uma letra: ").lower() # Solicita a entrada de uma letra

        if len(palpite) != 1: # Se for entrado mais de uma letra por vezes é impresso a mensagem de erro e o loop continua
            print("Por favor, digite apenas uma letra por vez.")
            continue

        if palpite in letras_corretas or palpite in letras_incorretas: # Se a letra já foi impressa uma vez vai ser impressa uma mensagem de erro e o loop continua
            print("Você já tentou essa letra. Tente novamente.")
            continue

        if palpite in palavra_secreta: # Se a letra (palpite) estiver certa ela é adicionada à lista de letras corretas
            letras_corretas.append(palpite)
        else:
            letras_incorretas.append(palpite) # Se a letra não estiver na palavra o palpite é adicionado a letras incorretas
            letras_tentadas.append(palpite)  # Adiciona a letra incorreta à lista de letras tentadas
            boneco += 1 # A cada erro no boneco a pontuação é reduzida
            pontuacao -= 1 # Pontuação é reduzida em 1 a cada erro
            print("Letra incorreta! Você ainda tem", tentativas - len(letras_incorretas), "tentativas restantes.") # A cada letra incorreta imprime quantas tentativas ainda restam
            desenhar_boneco(boneco) # Desenha boneco a cada erro

        print("\n") # Limpa o console

    return 0

def definir_dificuldade(nivel):
    if nivel.lower() == "fácil": # Retorna a dificuldade do jogo a partir da entrada escolhida pelo jogador
        return 1, 10, 4, 10 #os números do retorno correspondem ao limite minimo e máximo da pontuação, nº max de tentativas e pts iniciais da dificuldade respectiva
    elif nivel.lower() == "médio":
        return 1, 50, 4, 20 #os números do retorno correspondem ao limite minimo e máximo da pontuação, nº max de tentativas e pts iniciais da dificuldade respectiva
    elif nivel.lower() == "difícil":
        return 1, 100, 4, 30 #os números do retorno correspondem ao limite minimo e máximo da pontuação, nº max de tentativas e pts iniciais da dificuldade respectiva
    else:
        return None, None, None, 0 # Se nível não corresponder com os níveis anteriores (e a saída do nível errado também acontece)

def get_palavras(nivel): # Recebe o parâmetro nível que representa o nível de dificuldade
    if nivel.lower() == "fácil": #.lower aceita letras maiúsculas e minúsculas
        return ["Mouse", "Teclado", "Monitor", "Internet", "Software", "Hardware", "Armazenamento", "Processador", "Impressora", "Senha"]
    elif nivel.lower() == "médio":
        return ["Criptografia", "Firewall", "Algoritmo", "Rede", "Backup", "Cache", "Protocolo", "Malware", "API", "Navegador"]
    elif nivel.lower() == "difícil":
        return ["Criptografia", "Algoritmo", "Heurística", "Latência", "Virtualização", "Escalonamento", "Paralelismo", "Nuvem", "Autenticação", "CDD"]
    else:
        return []

def desenhar_boneco(boneco): #Função para desenhar o boneco
      matriz_boneco = [
        ["  O  "],
        [" /|\\ ", "  |  ", " / \\ "]
    ]

      partes_enforcado = len(matriz_boneco[1]) - boneco

      for i in range(partes_enforcado):
         for j in range(len(matriz_boneco)):
             if i < len(matriz_boneco[j]):
                print(matriz_boneco[j][i])

      print()

def main(): # Definir a função main
    num_jogadores = int(input("Digite o número de jogadores: "))
    jogadores = []

    for i in range(num_jogadores): # Loop para solicitar o nome dos jogadores
        nome = input(f"Digite o nome do jogador {i+1}: ")
        jogadores.append(nome)

    pontuacoes = []

    for jogador in jogadores:
        limpaTela()
        pontuacao = jogo(jogador) #Jogo é iniciado chamando a função jogo(jogador)
        pontuacoes.append((jogador, pontuacao)) # Retorna o nome do jogador e a pontuação


    print("=== RANKING ===") # Ordenado em ordem decrescente juntamente com o nome do jogador
    pontuacoes.sort(key=lambda x: x[1], reverse=True) # O parâmetro key específica como deve ser a comparação para a ordenação e "x: x[1]" é a chave de ordenação. Já reverse=True é usado para ordenar em ordem crescente
    for i, (jogador, pontuacao) in enumerate(pontuacoes): # Enumerate() é usada para obter tanto o índice quanto o valor de cada elemento na iteração
        print(f"{i+1}. {jogador} - Pontuação: {pontuacao}")  # Imprime a posição do jogador no ranking, seguido pelo nome e sua pontuação

    limpaTela()

main()

#Feito por Mariana Fagueiro, Leonardo Moret de Oliveira, Bruno Michelucci, Vinicius Yazbek e Victor Julio Garcia

